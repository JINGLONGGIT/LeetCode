## 21.合并两个有序链表


* 示例    
> 输入：1->2->4,&ensp;1->3->4  
> 输出：1->1->2->3->4->4  


* 算法思路
    * 依次比较链表 `List1` 和 `List2` 的大小。如果 `List1` 小于 `List2` ，则将 `List1` 的值插入到新的链表后面，然后移动 `List1` 的 `next` 指针；否则，将 `List2` 的值插入到新链表后面，然后移动 `List2` 的 `next` 指针。  
    * 如果其中一个链表的 `next` 指针移动到了链表末尾，则将另一个链表的剩余部分全部接在新链表后面


* 算法步骤
    * 申请一个头结点 `pHead` 作为新链表的头结点，同时维护一个头指针作为哨兵指针 `ptmp` 。起始哨兵指针指向头结点
    * 比较 `List1` 和 `List2` 的大小，如果 `List1` 小于 `List2` ，则将 `List1` 的值插入到哨兵指针 `ptmp` 的后面，然后移动 `List1` 的 `next` 指针；反之则对 `List2` 进行同样的操作。不管移动 `List1` 或 `List2` 的  `next` 指针，都需要移动哨兵指针 `ptmp` 的 `next` 指针
    * 如果其中一个链表的 `next` 指针移动到了链表末尾，则将另一个链表的剩余部分全部接在新链表后面
    * 返回头结点的 `next` 节点


* 附注
> 新增头结点：为了在两个链表合并之后容易返回结果链表  
> 新增哨兵指针：每次不需要移动头结点的 `next` 指针，只需要每次移动哨兵指针 `ptmp` 的 `next` 指针