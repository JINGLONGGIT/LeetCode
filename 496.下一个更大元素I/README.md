#496.下一个更大的数

* 题目说明
> `nums1` 是 `nums2` 的子集，所以 `nums1` 中的每个元素必然在 `nums2` 中存在。找到 `nums1` 中的元素 `x` 在 `nums2` 中对应位置的右边的第一个比 `x` 大的元素  
   
* 举例说明：对于以下两个数组 `nums1` 和 `nums2`  
> nums1[] = {4, 1, 2};  
> nums2[] = {1, 3, 4, 2};  
> nums1[] = {4, 1, 2};  
> nums2[] = {1, 3, 4, 2};  
* `nums1` 中的4对应的是 `nums2` 中的4，但是 `nums2` 中4的右边没有比4更大的数字，因此输出-1；  
* `nums1` 中的1对应的是 `nums2` 中的1，在 `nums2` 中1的右边比1更大的数字是3，因此输出3；  
* 同理对于 `nums1` 中的2对应的是 `nums2` 中的2，在 `nums2` 中2的右边没有比2更大的数字，因此输出-1；

### 算法思路——利用第三个栈实现
* 利用**栈**的思路，依次寻找 `nums1` 中的每个元素在 `nums2` 中的位置，然后判断该位置右侧是否存在比 `nums1` 中的元素大的值
* 需要用第三个栈来保存 `nums1` 和 `nums2` 比较时 `nums2` 中的元素  
* 边界条判断：空集是所有集合的子集 

> 实际上，因为采用的是数组，所以可以直接进行比较，不用将 `nums2` 中的元素移动到另一个数组中

### 算法步骤（两层循环）
* 依次**遍历** `nums1` 中的每一个元素 `x`，同时**遍历** `nums2`，寻找与其相等的元素的位置
* 在 `nums2` 中找到 `x` 的位置之后，**遍历** `nums2` 中 `x` 之后剩余的元素，寻找是否有比 `x` 更大的数。若没有则返回-1；如果有则返回那个更大的数
* 时间复杂度 O(n^2)
* 空间复杂度 O(1)