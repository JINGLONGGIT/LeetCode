# 532 数组中的K-diff数对
> 数对 `(i, j)` 和数对 `(j, i)` 被算作同一数对
> 异常判断：数组长度小于2或者k值小于0


## 不排序 + 二次循环（×）
> 如果在不排序的情况下进行二次循环的暴力解法，其中，`(j, i)`和`(i, j)`是同一数对的情况是无法判断出来的


## 排序 + 双指针（一）
* 算法思路
> 要消除数组中重复元素（即出现重复数对）的影响，可以对原数组进行排序，这样在指针移动的时候可以判断当前指针指向的元素是否和上一个元素相等


* 算法步骤
    1. 对数组由小到大进行排序
    2. 两层循环，每层循环维护一个指向数组元素的指针 `pOut`、`pIn`
    3. 外层循环 `pOut` 指针指向第一个元素，内层循环 `pIn` 指向外层循环指针指向的下一个元素
    4. 判断 `pOut - pIn == k ?`
    5. 移动 `pIn`，并判断 `pIn` 和 `pIn - 1` 是否相同。如果相同，继续移动`pIn`，否则，执行第4步
    > 判断 `pIn` 和 `pIn - 1` 是否相同的前提条件是 `j != i + 1`
    6. 当内层循环 `pIn` 移动到数组尾部，开始移动外层循环 `pOut`
    7. 判断 `pOut` 和 `pOut - 1` 是否相同。如果相同，继续移动 `pOut`, 否则，执行第4步
    >  判断 `pOut` 和 `pOut - 1` 是否相同：需要绕开 `pOut` 指向第1个元素和第2个元素的情况。因为排序后的前两个元素如果相同是可以作为数对的
    8. 当外层循环移动到倒数第二个元素，即结束所有循环，返回
    


* 时间复杂度  O(n^2)
* 空间复杂度  O(1)


## 排序 + 双指针（二）
* 算法思路
> 对数组进行排序，维护数组头尾两个指针 `pHead`和`pTail`，可以通过判断 `pHead - pTail` 和 `k` 值的大小来决定 `pHead` 向后移动或者 `pTail` 向前移动


* 算法步骤
    1. 从小到大排序
    2. 计算 `pHead - pTail` 的值，并和 `k` 值比较大小
    3. 如果 `pHead - pTail < k`，则头指针向后移动，并判断 `pHead` 和 `pHead - 1` 是否相同，如果相同，则继续移动，否则执行第2步
    > 判断 `pHead` 和 `pHead - 1` 是否相同：需要绕开 `pHead` 指向第一个元素和第二个元素的情况
    4. 反之，如果 `pHead - pTail > k`，则尾指针向前移动，并判断 `pTail` 和 `pTail` 和 `pTail + 1` 是否相同，如果相同，则继续移动，否则执行第2步
    5. 如果 `pHead - pTail == k`，则头尾指针同时移动，并且都需要判断是否和上一个移动前的元素相同


* 时间复杂度 O(n)
* 空间复杂度 O(1)